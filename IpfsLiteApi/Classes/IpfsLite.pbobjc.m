// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ipfs_lite.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import "IpfsLite.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"

#pragma mark - TTEIpfsLiteRoot

@implementation TTEIpfsLiteRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - TTEIpfsLiteRoot_FileDescriptor

static GPBFileDescriptor *TTEIpfsLiteRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"ipfs_lite"
                                                 objcPrefix:@"TTE"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - TTEAddParams

@implementation TTEAddParams

@dynamic layout;
@dynamic chunker;
@dynamic rawLeaves;
@dynamic hidden;
@dynamic shared;
@dynamic noCopy;
@dynamic hashFun;

typedef struct TTEAddParams__storage_ {
  uint32_t _has_storage_[1];
  NSString *layout;
  NSString *chunker;
  NSString *hashFun;
} TTEAddParams__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "layout",
        .dataTypeSpecific.className = NULL,
        .number = TTEAddParams_FieldNumber_Layout,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TTEAddParams__storage_, layout),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "chunker",
        .dataTypeSpecific.className = NULL,
        .number = TTEAddParams_FieldNumber_Chunker,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TTEAddParams__storage_, chunker),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "rawLeaves",
        .dataTypeSpecific.className = NULL,
        .number = TTEAddParams_FieldNumber_RawLeaves,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "hidden",
        .dataTypeSpecific.className = NULL,
        .number = TTEAddParams_FieldNumber_Hidden,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "shared",
        .dataTypeSpecific.className = NULL,
        .number = TTEAddParams_FieldNumber_Shared,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "noCopy",
        .dataTypeSpecific.className = NULL,
        .number = TTEAddParams_FieldNumber_NoCopy,
        .hasIndex = 8,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "hashFun",
        .dataTypeSpecific.className = NULL,
        .number = TTEAddParams_FieldNumber_HashFun,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(TTEAddParams__storage_, hashFun),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTEAddParams class]
                                     rootClass:[TTEIpfsLiteRoot class]
                                          file:TTEIpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TTEAddParams__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\003\t\000\006\006\000\007\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TTEBlock

@implementation TTEBlock

@dynamic rawData;
@dynamic cid;

typedef struct TTEBlock__storage_ {
  uint32_t _has_storage_[1];
  NSData *rawData;
  NSString *cid;
} TTEBlock__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rawData",
        .dataTypeSpecific.className = NULL,
        .number = TTEBlock_FieldNumber_RawData,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TTEBlock__storage_, rawData),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "cid",
        .dataTypeSpecific.className = NULL,
        .number = TTEBlock_FieldNumber_Cid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TTEBlock__storage_, cid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTEBlock class]
                                     rootClass:[TTEIpfsLiteRoot class]
                                          file:TTEIpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TTEBlock__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TTELink

@implementation TTELink

@dynamic name;
@dynamic size;
@dynamic cid;

typedef struct TTELink__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *cid;
  int64_t size;
} TTELink__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = TTELink_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TTELink__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "size",
        .dataTypeSpecific.className = NULL,
        .number = TTELink_FieldNumber_Size,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TTELink__storage_, size),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "cid",
        .dataTypeSpecific.className = NULL,
        .number = TTELink_FieldNumber_Cid,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TTELink__storage_, cid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTELink class]
                                     rootClass:[TTEIpfsLiteRoot class]
                                          file:TTEIpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TTELink__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TTENodeStat

@implementation TTENodeStat

@dynamic hash_p;
@dynamic numLinks;
@dynamic blockSize;
@dynamic linksSize;
@dynamic dataSize;
@dynamic cumulativeSize;

typedef struct TTENodeStat__storage_ {
  uint32_t _has_storage_[1];
  int32_t numLinks;
  int32_t blockSize;
  int32_t linksSize;
  int32_t dataSize;
  int32_t cumulativeSize;
  NSString *hash_p;
} TTENodeStat__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hash_p",
        .dataTypeSpecific.className = NULL,
        .number = TTENodeStat_FieldNumber_Hash_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TTENodeStat__storage_, hash_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "numLinks",
        .dataTypeSpecific.className = NULL,
        .number = TTENodeStat_FieldNumber_NumLinks,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TTENodeStat__storage_, numLinks),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "blockSize",
        .dataTypeSpecific.className = NULL,
        .number = TTENodeStat_FieldNumber_BlockSize,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TTENodeStat__storage_, blockSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "linksSize",
        .dataTypeSpecific.className = NULL,
        .number = TTENodeStat_FieldNumber_LinksSize,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TTENodeStat__storage_, linksSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "dataSize",
        .dataTypeSpecific.className = NULL,
        .number = TTENodeStat_FieldNumber_DataSize,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(TTENodeStat__storage_, dataSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "cumulativeSize",
        .dataTypeSpecific.className = NULL,
        .number = TTENodeStat_FieldNumber_CumulativeSize,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(TTENodeStat__storage_, cumulativeSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTENodeStat class]
                                     rootClass:[TTEIpfsLiteRoot class]
                                          file:TTEIpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TTENodeStat__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\002\010\000\003\t\000\004\t\000\005\010\000\006\016\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TTENode

@implementation TTENode

@dynamic hasBlock, block;
@dynamic linksArray, linksArray_Count;
@dynamic hasStat, stat;
@dynamic size;

typedef struct TTENode__storage_ {
  uint32_t _has_storage_[1];
  TTEBlock *block;
  NSMutableArray *linksArray;
  TTENodeStat *stat;
  int64_t size;
} TTENode__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "block",
        .dataTypeSpecific.className = GPBStringifySymbol(TTEBlock),
        .number = TTENode_FieldNumber_Block,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TTENode__storage_, block),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "linksArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TTELink),
        .number = TTENode_FieldNumber_LinksArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TTENode__storage_, linksArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "stat",
        .dataTypeSpecific.className = GPBStringifySymbol(TTENodeStat),
        .number = TTENode_FieldNumber_Stat,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TTENode__storage_, stat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "size",
        .dataTypeSpecific.className = NULL,
        .number = TTENode_FieldNumber_Size,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TTENode__storage_, size),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTENode class]
                                     rootClass:[TTEIpfsLiteRoot class]
                                          file:TTEIpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TTENode__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TTEAddFileRequest

@implementation TTEAddFileRequest

@dynamic payloadOneOfCase;
@dynamic addParams;
@dynamic chunk;

typedef struct TTEAddFileRequest__storage_ {
  uint32_t _has_storage_[2];
  TTEAddParams *addParams;
  NSData *chunk;
} TTEAddFileRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addParams",
        .dataTypeSpecific.className = GPBStringifySymbol(TTEAddParams),
        .number = TTEAddFileRequest_FieldNumber_AddParams,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(TTEAddFileRequest__storage_, addParams),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "chunk",
        .dataTypeSpecific.className = NULL,
        .number = TTEAddFileRequest_FieldNumber_Chunk,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(TTEAddFileRequest__storage_, chunk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTEAddFileRequest class]
                                     rootClass:[TTEIpfsLiteRoot class]
                                          file:TTEIpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TTEAddFileRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "payload",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void TTEAddFileRequest_ClearPayloadOneOfCase(TTEAddFileRequest *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - TTEAddFileResponse

@implementation TTEAddFileResponse

@dynamic hasNode, node;

typedef struct TTEAddFileResponse__storage_ {
  uint32_t _has_storage_[1];
  TTENode *node;
} TTEAddFileResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "node",
        .dataTypeSpecific.className = GPBStringifySymbol(TTENode),
        .number = TTEAddFileResponse_FieldNumber_Node,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TTEAddFileResponse__storage_, node),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTEAddFileResponse class]
                                     rootClass:[TTEIpfsLiteRoot class]
                                          file:TTEIpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TTEAddFileResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TTEGetFileRequest

@implementation TTEGetFileRequest

@dynamic cid;

typedef struct TTEGetFileRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *cid;
} TTEGetFileRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cid",
        .dataTypeSpecific.className = NULL,
        .number = TTEGetFileRequest_FieldNumber_Cid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TTEGetFileRequest__storage_, cid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTEGetFileRequest class]
                                     rootClass:[TTEIpfsLiteRoot class]
                                          file:TTEIpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TTEGetFileRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TTEGetFileResponse

@implementation TTEGetFileResponse

@dynamic chunk;

typedef struct TTEGetFileResponse__storage_ {
  uint32_t _has_storage_[1];
  NSData *chunk;
} TTEGetFileResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chunk",
        .dataTypeSpecific.className = NULL,
        .number = TTEGetFileResponse_FieldNumber_Chunk,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TTEGetFileResponse__storage_, chunk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTEGetFileResponse class]
                                     rootClass:[TTEIpfsLiteRoot class]
                                          file:TTEIpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TTEGetFileResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TTEAddNodeRequest

@implementation TTEAddNodeRequest

@dynamic hasBlock, block;

typedef struct TTEAddNodeRequest__storage_ {
  uint32_t _has_storage_[1];
  TTEBlock *block;
} TTEAddNodeRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "block",
        .dataTypeSpecific.className = GPBStringifySymbol(TTEBlock),
        .number = TTEAddNodeRequest_FieldNumber_Block,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TTEAddNodeRequest__storage_, block),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTEAddNodeRequest class]
                                     rootClass:[TTEIpfsLiteRoot class]
                                          file:TTEIpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TTEAddNodeRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TTEAddNodeResponse

@implementation TTEAddNodeResponse


typedef struct TTEAddNodeResponse__storage_ {
  uint32_t _has_storage_[1];
} TTEAddNodeResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTEAddNodeResponse class]
                                     rootClass:[TTEIpfsLiteRoot class]
                                          file:TTEIpfsLiteRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(TTEAddNodeResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TTEAddNodesRequest

@implementation TTEAddNodesRequest

@dynamic blocksArray, blocksArray_Count;

typedef struct TTEAddNodesRequest__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *blocksArray;
} TTEAddNodesRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "blocksArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TTEBlock),
        .number = TTEAddNodesRequest_FieldNumber_BlocksArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TTEAddNodesRequest__storage_, blocksArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTEAddNodesRequest class]
                                     rootClass:[TTEIpfsLiteRoot class]
                                          file:TTEIpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TTEAddNodesRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TTEAddNodesResponse

@implementation TTEAddNodesResponse


typedef struct TTEAddNodesResponse__storage_ {
  uint32_t _has_storage_[1];
} TTEAddNodesResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTEAddNodesResponse class]
                                     rootClass:[TTEIpfsLiteRoot class]
                                          file:TTEIpfsLiteRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(TTEAddNodesResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TTEGetNodeRequest

@implementation TTEGetNodeRequest

@dynamic cid;

typedef struct TTEGetNodeRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *cid;
} TTEGetNodeRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cid",
        .dataTypeSpecific.className = NULL,
        .number = TTEGetNodeRequest_FieldNumber_Cid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TTEGetNodeRequest__storage_, cid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTEGetNodeRequest class]
                                     rootClass:[TTEIpfsLiteRoot class]
                                          file:TTEIpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TTEGetNodeRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TTEGetNodeResponse

@implementation TTEGetNodeResponse

@dynamic hasNode, node;

typedef struct TTEGetNodeResponse__storage_ {
  uint32_t _has_storage_[1];
  TTENode *node;
} TTEGetNodeResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "node",
        .dataTypeSpecific.className = GPBStringifySymbol(TTENode),
        .number = TTEGetNodeResponse_FieldNumber_Node,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TTEGetNodeResponse__storage_, node),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTEGetNodeResponse class]
                                     rootClass:[TTEIpfsLiteRoot class]
                                          file:TTEIpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TTEGetNodeResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TTEGetNodesRequest

@implementation TTEGetNodesRequest

@dynamic cidsArray, cidsArray_Count;

typedef struct TTEGetNodesRequest__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *cidsArray;
} TTEGetNodesRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cidsArray",
        .dataTypeSpecific.className = NULL,
        .number = TTEGetNodesRequest_FieldNumber_CidsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TTEGetNodesRequest__storage_, cidsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTEGetNodesRequest class]
                                     rootClass:[TTEIpfsLiteRoot class]
                                          file:TTEIpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TTEGetNodesRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TTEGetNodesResponse

@implementation TTEGetNodesResponse

@dynamic optionOneOfCase;
@dynamic node;
@dynamic error;

typedef struct TTEGetNodesResponse__storage_ {
  uint32_t _has_storage_[2];
  TTENode *node;
  NSString *error;
} TTEGetNodesResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "node",
        .dataTypeSpecific.className = GPBStringifySymbol(TTENode),
        .number = TTEGetNodesResponse_FieldNumber_Node,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(TTEGetNodesResponse__storage_, node),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "error",
        .dataTypeSpecific.className = NULL,
        .number = TTEGetNodesResponse_FieldNumber_Error,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(TTEGetNodesResponse__storage_, error),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTEGetNodesResponse class]
                                     rootClass:[TTEIpfsLiteRoot class]
                                          file:TTEIpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TTEGetNodesResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "option",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void TTEGetNodesResponse_ClearOptionOneOfCase(TTEGetNodesResponse *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - TTERemoveNodeRequest

@implementation TTERemoveNodeRequest

@dynamic cid;

typedef struct TTERemoveNodeRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *cid;
} TTERemoveNodeRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cid",
        .dataTypeSpecific.className = NULL,
        .number = TTERemoveNodeRequest_FieldNumber_Cid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TTERemoveNodeRequest__storage_, cid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTERemoveNodeRequest class]
                                     rootClass:[TTEIpfsLiteRoot class]
                                          file:TTEIpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TTERemoveNodeRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TTERemoveNodeResponse

@implementation TTERemoveNodeResponse


typedef struct TTERemoveNodeResponse__storage_ {
  uint32_t _has_storage_[1];
} TTERemoveNodeResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTERemoveNodeResponse class]
                                     rootClass:[TTEIpfsLiteRoot class]
                                          file:TTEIpfsLiteRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(TTERemoveNodeResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TTERemoveNodesRequest

@implementation TTERemoveNodesRequest

@dynamic cidsArray, cidsArray_Count;

typedef struct TTERemoveNodesRequest__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *cidsArray;
} TTERemoveNodesRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cidsArray",
        .dataTypeSpecific.className = NULL,
        .number = TTERemoveNodesRequest_FieldNumber_CidsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TTERemoveNodesRequest__storage_, cidsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTERemoveNodesRequest class]
                                     rootClass:[TTEIpfsLiteRoot class]
                                          file:TTEIpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TTERemoveNodesRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TTERemoveNodesResponse

@implementation TTERemoveNodesResponse


typedef struct TTERemoveNodesResponse__storage_ {
  uint32_t _has_storage_[1];
} TTERemoveNodesResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTERemoveNodesResponse class]
                                     rootClass:[TTEIpfsLiteRoot class]
                                          file:TTEIpfsLiteRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(TTERemoveNodesResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TTEResolveLinkRequest

@implementation TTEResolveLinkRequest

@dynamic nodeCid;
@dynamic pathArray, pathArray_Count;

typedef struct TTEResolveLinkRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *nodeCid;
  NSMutableArray *pathArray;
} TTEResolveLinkRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nodeCid",
        .dataTypeSpecific.className = NULL,
        .number = TTEResolveLinkRequest_FieldNumber_NodeCid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TTEResolveLinkRequest__storage_, nodeCid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pathArray",
        .dataTypeSpecific.className = NULL,
        .number = TTEResolveLinkRequest_FieldNumber_PathArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TTEResolveLinkRequest__storage_, pathArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTEResolveLinkRequest class]
                                     rootClass:[TTEIpfsLiteRoot class]
                                          file:TTEIpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TTEResolveLinkRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TTEResolveLinkResponse

@implementation TTEResolveLinkResponse

@dynamic hasLink, link;
@dynamic remainingPathArray, remainingPathArray_Count;

typedef struct TTEResolveLinkResponse__storage_ {
  uint32_t _has_storage_[1];
  TTELink *link;
  NSMutableArray *remainingPathArray;
} TTEResolveLinkResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "link",
        .dataTypeSpecific.className = GPBStringifySymbol(TTELink),
        .number = TTEResolveLinkResponse_FieldNumber_Link,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TTEResolveLinkResponse__storage_, link),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "remainingPathArray",
        .dataTypeSpecific.className = NULL,
        .number = TTEResolveLinkResponse_FieldNumber_RemainingPathArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TTEResolveLinkResponse__storage_, remainingPathArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTEResolveLinkResponse class]
                                     rootClass:[TTEIpfsLiteRoot class]
                                          file:TTEIpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TTEResolveLinkResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\000remainingPath\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TTETreeRequest

@implementation TTETreeRequest

@dynamic nodeCid;
@dynamic path;
@dynamic depth;

typedef struct TTETreeRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t depth;
  NSString *nodeCid;
  NSString *path;
} TTETreeRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nodeCid",
        .dataTypeSpecific.className = NULL,
        .number = TTETreeRequest_FieldNumber_NodeCid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TTETreeRequest__storage_, nodeCid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "path",
        .dataTypeSpecific.className = NULL,
        .number = TTETreeRequest_FieldNumber_Path,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TTETreeRequest__storage_, path),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "depth",
        .dataTypeSpecific.className = NULL,
        .number = TTETreeRequest_FieldNumber_Depth,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TTETreeRequest__storage_, depth),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTETreeRequest class]
                                     rootClass:[TTEIpfsLiteRoot class]
                                          file:TTEIpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TTETreeRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TTETreeResponse

@implementation TTETreeResponse

@dynamic pathsArray, pathsArray_Count;

typedef struct TTETreeResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *pathsArray;
} TTETreeResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pathsArray",
        .dataTypeSpecific.className = NULL,
        .number = TTETreeResponse_FieldNumber_PathsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TTETreeResponse__storage_, pathsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTETreeResponse class]
                                     rootClass:[TTEIpfsLiteRoot class]
                                          file:TTEIpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TTETreeResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TTEDeleteBlockRequest

@implementation TTEDeleteBlockRequest

@dynamic cid;

typedef struct TTEDeleteBlockRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *cid;
} TTEDeleteBlockRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cid",
        .dataTypeSpecific.className = NULL,
        .number = TTEDeleteBlockRequest_FieldNumber_Cid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TTEDeleteBlockRequest__storage_, cid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTEDeleteBlockRequest class]
                                     rootClass:[TTEIpfsLiteRoot class]
                                          file:TTEIpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TTEDeleteBlockRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TTEDeleteBlockResponse

@implementation TTEDeleteBlockResponse


typedef struct TTEDeleteBlockResponse__storage_ {
  uint32_t _has_storage_[1];
} TTEDeleteBlockResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTEDeleteBlockResponse class]
                                     rootClass:[TTEIpfsLiteRoot class]
                                          file:TTEIpfsLiteRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(TTEDeleteBlockResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TTEHasBlockRequest

@implementation TTEHasBlockRequest

@dynamic cid;

typedef struct TTEHasBlockRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *cid;
} TTEHasBlockRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cid",
        .dataTypeSpecific.className = NULL,
        .number = TTEHasBlockRequest_FieldNumber_Cid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TTEHasBlockRequest__storage_, cid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTEHasBlockRequest class]
                                     rootClass:[TTEIpfsLiteRoot class]
                                          file:TTEIpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TTEHasBlockRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TTEHasBlockResponse

@implementation TTEHasBlockResponse

@dynamic hasBlock;

typedef struct TTEHasBlockResponse__storage_ {
  uint32_t _has_storage_[1];
} TTEHasBlockResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hasBlock",
        .dataTypeSpecific.className = NULL,
        .number = TTEHasBlockResponse_FieldNumber_HasBlock,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTEHasBlockResponse class]
                                     rootClass:[TTEIpfsLiteRoot class]
                                          file:TTEIpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TTEHasBlockResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TTEGetBlockRequest

@implementation TTEGetBlockRequest

@dynamic cid;

typedef struct TTEGetBlockRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *cid;
} TTEGetBlockRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cid",
        .dataTypeSpecific.className = NULL,
        .number = TTEGetBlockRequest_FieldNumber_Cid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TTEGetBlockRequest__storage_, cid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTEGetBlockRequest class]
                                     rootClass:[TTEIpfsLiteRoot class]
                                          file:TTEIpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TTEGetBlockRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TTEGetBlockResponse

@implementation TTEGetBlockResponse

@dynamic hasBlock, block;

typedef struct TTEGetBlockResponse__storage_ {
  uint32_t _has_storage_[1];
  TTEBlock *block;
} TTEGetBlockResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "block",
        .dataTypeSpecific.className = GPBStringifySymbol(TTEBlock),
        .number = TTEGetBlockResponse_FieldNumber_Block,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TTEGetBlockResponse__storage_, block),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTEGetBlockResponse class]
                                     rootClass:[TTEIpfsLiteRoot class]
                                          file:TTEIpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TTEGetBlockResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TTEGetBlockSizeRequest

@implementation TTEGetBlockSizeRequest

@dynamic cid;

typedef struct TTEGetBlockSizeRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *cid;
} TTEGetBlockSizeRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cid",
        .dataTypeSpecific.className = NULL,
        .number = TTEGetBlockSizeRequest_FieldNumber_Cid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TTEGetBlockSizeRequest__storage_, cid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTEGetBlockSizeRequest class]
                                     rootClass:[TTEIpfsLiteRoot class]
                                          file:TTEIpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TTEGetBlockSizeRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TTEGetBlockSizeResponse

@implementation TTEGetBlockSizeResponse

@dynamic size;

typedef struct TTEGetBlockSizeResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t size;
} TTEGetBlockSizeResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "size",
        .dataTypeSpecific.className = NULL,
        .number = TTEGetBlockSizeResponse_FieldNumber_Size,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TTEGetBlockSizeResponse__storage_, size),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTEGetBlockSizeResponse class]
                                     rootClass:[TTEIpfsLiteRoot class]
                                          file:TTEIpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TTEGetBlockSizeResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TTEPutBlockRequest

@implementation TTEPutBlockRequest

@dynamic hasBlock, block;

typedef struct TTEPutBlockRequest__storage_ {
  uint32_t _has_storage_[1];
  TTEBlock *block;
} TTEPutBlockRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "block",
        .dataTypeSpecific.className = GPBStringifySymbol(TTEBlock),
        .number = TTEPutBlockRequest_FieldNumber_Block,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TTEPutBlockRequest__storage_, block),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTEPutBlockRequest class]
                                     rootClass:[TTEIpfsLiteRoot class]
                                          file:TTEIpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TTEPutBlockRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TTEPutBlockResponse

@implementation TTEPutBlockResponse


typedef struct TTEPutBlockResponse__storage_ {
  uint32_t _has_storage_[1];
} TTEPutBlockResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTEPutBlockResponse class]
                                     rootClass:[TTEIpfsLiteRoot class]
                                          file:TTEIpfsLiteRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(TTEPutBlockResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TTEPutBlocksRequest

@implementation TTEPutBlocksRequest

@dynamic blocksArray, blocksArray_Count;

typedef struct TTEPutBlocksRequest__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *blocksArray;
} TTEPutBlocksRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "blocksArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TTEBlock),
        .number = TTEPutBlocksRequest_FieldNumber_BlocksArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TTEPutBlocksRequest__storage_, blocksArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTEPutBlocksRequest class]
                                     rootClass:[TTEIpfsLiteRoot class]
                                          file:TTEIpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TTEPutBlocksRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TTEPutBlocksResponse

@implementation TTEPutBlocksResponse


typedef struct TTEPutBlocksResponse__storage_ {
  uint32_t _has_storage_[1];
} TTEPutBlocksResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTEPutBlocksResponse class]
                                     rootClass:[TTEIpfsLiteRoot class]
                                          file:TTEIpfsLiteRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(TTEPutBlocksResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TTEAllKeysRequest

@implementation TTEAllKeysRequest


typedef struct TTEAllKeysRequest__storage_ {
  uint32_t _has_storage_[1];
} TTEAllKeysRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTEAllKeysRequest class]
                                     rootClass:[TTEIpfsLiteRoot class]
                                          file:TTEIpfsLiteRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(TTEAllKeysRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TTEAllKeysResponse

@implementation TTEAllKeysResponse

@dynamic cid;

typedef struct TTEAllKeysResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *cid;
} TTEAllKeysResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cid",
        .dataTypeSpecific.className = NULL,
        .number = TTEAllKeysResponse_FieldNumber_Cid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TTEAllKeysResponse__storage_, cid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTEAllKeysResponse class]
                                     rootClass:[TTEIpfsLiteRoot class]
                                          file:TTEIpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TTEAllKeysResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TTEHashOnReadRequest

@implementation TTEHashOnReadRequest

@dynamic hashOnRead;

typedef struct TTEHashOnReadRequest__storage_ {
  uint32_t _has_storage_[1];
} TTEHashOnReadRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hashOnRead",
        .dataTypeSpecific.className = NULL,
        .number = TTEHashOnReadRequest_FieldNumber_HashOnRead,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTEHashOnReadRequest class]
                                     rootClass:[TTEIpfsLiteRoot class]
                                          file:TTEIpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TTEHashOnReadRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TTEHashOnReadResponse

@implementation TTEHashOnReadResponse


typedef struct TTEHashOnReadResponse__storage_ {
  uint32_t _has_storage_[1];
} TTEHashOnReadResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TTEHashOnReadResponse class]
                                     rootClass:[TTEIpfsLiteRoot class]
                                          file:TTEIpfsLiteRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(TTEHashOnReadResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
