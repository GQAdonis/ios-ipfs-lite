// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ipfs_lite.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import "IpfsLite.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"

#pragma mark - IpfsLiteRoot

@implementation IpfsLiteRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - IpfsLiteRoot_FileDescriptor

static GPBFileDescriptor *IpfsLiteRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@""
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - AddParams

@implementation AddParams

@dynamic layout;
@dynamic chunker;
@dynamic rawLeaves;
@dynamic hidden;
@dynamic shared;
@dynamic noCopy;
@dynamic hashFun;

typedef struct AddParams__storage_ {
  uint32_t _has_storage_[1];
  NSString *layout;
  NSString *chunker;
  NSString *hashFun;
} AddParams__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "layout",
        .dataTypeSpecific.className = NULL,
        .number = AddParams_FieldNumber_Layout,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AddParams__storage_, layout),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "chunker",
        .dataTypeSpecific.className = NULL,
        .number = AddParams_FieldNumber_Chunker,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AddParams__storage_, chunker),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "rawLeaves",
        .dataTypeSpecific.className = NULL,
        .number = AddParams_FieldNumber_RawLeaves,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "hidden",
        .dataTypeSpecific.className = NULL,
        .number = AddParams_FieldNumber_Hidden,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "shared",
        .dataTypeSpecific.className = NULL,
        .number = AddParams_FieldNumber_Shared,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "noCopy",
        .dataTypeSpecific.className = NULL,
        .number = AddParams_FieldNumber_NoCopy,
        .hasIndex = 8,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "hashFun",
        .dataTypeSpecific.className = NULL,
        .number = AddParams_FieldNumber_HashFun,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(AddParams__storage_, hashFun),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AddParams class]
                                     rootClass:[IpfsLiteRoot class]
                                          file:IpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AddParams__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\003\t\000\006\006\000\007\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Block

@implementation Block

@dynamic rawData;
@dynamic cid;

typedef struct Block__storage_ {
  uint32_t _has_storage_[1];
  NSData *rawData;
  NSString *cid;
} Block__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rawData",
        .dataTypeSpecific.className = NULL,
        .number = Block_FieldNumber_RawData,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Block__storage_, rawData),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "cid",
        .dataTypeSpecific.className = NULL,
        .number = Block_FieldNumber_Cid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Block__storage_, cid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Block class]
                                     rootClass:[IpfsLiteRoot class]
                                          file:IpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Block__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Link

@implementation Link

@dynamic name;
@dynamic size;
@dynamic cid;

typedef struct Link__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *cid;
  int64_t size;
} Link__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = Link_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Link__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "size",
        .dataTypeSpecific.className = NULL,
        .number = Link_FieldNumber_Size,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Link__storage_, size),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "cid",
        .dataTypeSpecific.className = NULL,
        .number = Link_FieldNumber_Cid,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Link__storage_, cid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Link class]
                                     rootClass:[IpfsLiteRoot class]
                                          file:IpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Link__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NodeStat

@implementation NodeStat

@dynamic hash_p;
@dynamic numLinks;
@dynamic blockSize;
@dynamic linksSize;
@dynamic dataSize;
@dynamic cumulativeSize;

typedef struct NodeStat__storage_ {
  uint32_t _has_storage_[1];
  int32_t numLinks;
  int32_t blockSize;
  int32_t linksSize;
  int32_t dataSize;
  int32_t cumulativeSize;
  NSString *hash_p;
} NodeStat__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hash_p",
        .dataTypeSpecific.className = NULL,
        .number = NodeStat_FieldNumber_Hash_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NodeStat__storage_, hash_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "numLinks",
        .dataTypeSpecific.className = NULL,
        .number = NodeStat_FieldNumber_NumLinks,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NodeStat__storage_, numLinks),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "blockSize",
        .dataTypeSpecific.className = NULL,
        .number = NodeStat_FieldNumber_BlockSize,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NodeStat__storage_, blockSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "linksSize",
        .dataTypeSpecific.className = NULL,
        .number = NodeStat_FieldNumber_LinksSize,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(NodeStat__storage_, linksSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "dataSize",
        .dataTypeSpecific.className = NULL,
        .number = NodeStat_FieldNumber_DataSize,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(NodeStat__storage_, dataSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "cumulativeSize",
        .dataTypeSpecific.className = NULL,
        .number = NodeStat_FieldNumber_CumulativeSize,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(NodeStat__storage_, cumulativeSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NodeStat class]
                                     rootClass:[IpfsLiteRoot class]
                                          file:IpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NodeStat__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\002\010\000\003\t\000\004\t\000\005\010\000\006\016\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Node

@implementation Node

@dynamic hasBlock, block;
@dynamic linksArray, linksArray_Count;
@dynamic hasStat, stat;
@dynamic size;

typedef struct Node__storage_ {
  uint32_t _has_storage_[1];
  Block *block;
  NSMutableArray *linksArray;
  NodeStat *stat;
  int64_t size;
} Node__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "block",
        .dataTypeSpecific.className = GPBStringifySymbol(Block),
        .number = Node_FieldNumber_Block,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Node__storage_, block),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "linksArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Link),
        .number = Node_FieldNumber_LinksArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Node__storage_, linksArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "stat",
        .dataTypeSpecific.className = GPBStringifySymbol(NodeStat),
        .number = Node_FieldNumber_Stat,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Node__storage_, stat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "size",
        .dataTypeSpecific.className = NULL,
        .number = Node_FieldNumber_Size,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Node__storage_, size),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Node class]
                                     rootClass:[IpfsLiteRoot class]
                                          file:IpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Node__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AddFileRequest

@implementation AddFileRequest

@dynamic payloadOneOfCase;
@dynamic addParams;
@dynamic chunk;

typedef struct AddFileRequest__storage_ {
  uint32_t _has_storage_[2];
  AddParams *addParams;
  NSData *chunk;
} AddFileRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "addParams",
        .dataTypeSpecific.className = GPBStringifySymbol(AddParams),
        .number = AddFileRequest_FieldNumber_AddParams,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(AddFileRequest__storage_, addParams),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "chunk",
        .dataTypeSpecific.className = NULL,
        .number = AddFileRequest_FieldNumber_Chunk,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(AddFileRequest__storage_, chunk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AddFileRequest class]
                                     rootClass:[IpfsLiteRoot class]
                                          file:IpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AddFileRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "payload",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void AddFileRequest_ClearPayloadOneOfCase(AddFileRequest *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - AddFileResponse

@implementation AddFileResponse

@dynamic hasNode, node;

typedef struct AddFileResponse__storage_ {
  uint32_t _has_storage_[1];
  Node *node;
} AddFileResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "node",
        .dataTypeSpecific.className = GPBStringifySymbol(Node),
        .number = AddFileResponse_FieldNumber_Node,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AddFileResponse__storage_, node),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AddFileResponse class]
                                     rootClass:[IpfsLiteRoot class]
                                          file:IpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AddFileResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetFileRequest

@implementation GetFileRequest

@dynamic cid;

typedef struct GetFileRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *cid;
} GetFileRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cid",
        .dataTypeSpecific.className = NULL,
        .number = GetFileRequest_FieldNumber_Cid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetFileRequest__storage_, cid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetFileRequest class]
                                     rootClass:[IpfsLiteRoot class]
                                          file:IpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetFileRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetFileResponse

@implementation GetFileResponse

@dynamic chunk;

typedef struct GetFileResponse__storage_ {
  uint32_t _has_storage_[1];
  NSData *chunk;
} GetFileResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chunk",
        .dataTypeSpecific.className = NULL,
        .number = GetFileResponse_FieldNumber_Chunk,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetFileResponse__storage_, chunk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetFileResponse class]
                                     rootClass:[IpfsLiteRoot class]
                                          file:IpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetFileResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AddNodeRequest

@implementation AddNodeRequest

@dynamic hasBlock, block;

typedef struct AddNodeRequest__storage_ {
  uint32_t _has_storage_[1];
  Block *block;
} AddNodeRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "block",
        .dataTypeSpecific.className = GPBStringifySymbol(Block),
        .number = AddNodeRequest_FieldNumber_Block,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AddNodeRequest__storage_, block),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AddNodeRequest class]
                                     rootClass:[IpfsLiteRoot class]
                                          file:IpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AddNodeRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AddNodeResponse

@implementation AddNodeResponse


typedef struct AddNodeResponse__storage_ {
  uint32_t _has_storage_[1];
} AddNodeResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AddNodeResponse class]
                                     rootClass:[IpfsLiteRoot class]
                                          file:IpfsLiteRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(AddNodeResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AddNodesRequest

@implementation AddNodesRequest

@dynamic blocksArray, blocksArray_Count;

typedef struct AddNodesRequest__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *blocksArray;
} AddNodesRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "blocksArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Block),
        .number = AddNodesRequest_FieldNumber_BlocksArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AddNodesRequest__storage_, blocksArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AddNodesRequest class]
                                     rootClass:[IpfsLiteRoot class]
                                          file:IpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AddNodesRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AddNodesResponse

@implementation AddNodesResponse


typedef struct AddNodesResponse__storage_ {
  uint32_t _has_storage_[1];
} AddNodesResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AddNodesResponse class]
                                     rootClass:[IpfsLiteRoot class]
                                          file:IpfsLiteRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(AddNodesResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetNodeRequest

@implementation GetNodeRequest

@dynamic cid;

typedef struct GetNodeRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *cid;
} GetNodeRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cid",
        .dataTypeSpecific.className = NULL,
        .number = GetNodeRequest_FieldNumber_Cid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetNodeRequest__storage_, cid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetNodeRequest class]
                                     rootClass:[IpfsLiteRoot class]
                                          file:IpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetNodeRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetNodeResponse

@implementation GetNodeResponse

@dynamic hasNode, node;

typedef struct GetNodeResponse__storage_ {
  uint32_t _has_storage_[1];
  Node *node;
} GetNodeResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "node",
        .dataTypeSpecific.className = GPBStringifySymbol(Node),
        .number = GetNodeResponse_FieldNumber_Node,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetNodeResponse__storage_, node),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetNodeResponse class]
                                     rootClass:[IpfsLiteRoot class]
                                          file:IpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetNodeResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetNodesRequest

@implementation GetNodesRequest

@dynamic cidsArray, cidsArray_Count;

typedef struct GetNodesRequest__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *cidsArray;
} GetNodesRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cidsArray",
        .dataTypeSpecific.className = NULL,
        .number = GetNodesRequest_FieldNumber_CidsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetNodesRequest__storage_, cidsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetNodesRequest class]
                                     rootClass:[IpfsLiteRoot class]
                                          file:IpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetNodesRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetNodesResponse

@implementation GetNodesResponse

@dynamic optionOneOfCase;
@dynamic node;
@dynamic error;

typedef struct GetNodesResponse__storage_ {
  uint32_t _has_storage_[2];
  Node *node;
  NSString *error;
} GetNodesResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "node",
        .dataTypeSpecific.className = GPBStringifySymbol(Node),
        .number = GetNodesResponse_FieldNumber_Node,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetNodesResponse__storage_, node),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "error",
        .dataTypeSpecific.className = NULL,
        .number = GetNodesResponse_FieldNumber_Error,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GetNodesResponse__storage_, error),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetNodesResponse class]
                                     rootClass:[IpfsLiteRoot class]
                                          file:IpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetNodesResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "option",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GetNodesResponse_ClearOptionOneOfCase(GetNodesResponse *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - RemoveNodeRequest

@implementation RemoveNodeRequest

@dynamic cid;

typedef struct RemoveNodeRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *cid;
} RemoveNodeRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cid",
        .dataTypeSpecific.className = NULL,
        .number = RemoveNodeRequest_FieldNumber_Cid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RemoveNodeRequest__storage_, cid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RemoveNodeRequest class]
                                     rootClass:[IpfsLiteRoot class]
                                          file:IpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RemoveNodeRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RemoveNodeResponse

@implementation RemoveNodeResponse


typedef struct RemoveNodeResponse__storage_ {
  uint32_t _has_storage_[1];
} RemoveNodeResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RemoveNodeResponse class]
                                     rootClass:[IpfsLiteRoot class]
                                          file:IpfsLiteRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(RemoveNodeResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RemoveNodesRequest

@implementation RemoveNodesRequest

@dynamic cidsArray, cidsArray_Count;

typedef struct RemoveNodesRequest__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *cidsArray;
} RemoveNodesRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cidsArray",
        .dataTypeSpecific.className = NULL,
        .number = RemoveNodesRequest_FieldNumber_CidsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RemoveNodesRequest__storage_, cidsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RemoveNodesRequest class]
                                     rootClass:[IpfsLiteRoot class]
                                          file:IpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RemoveNodesRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RemoveNodesResponse

@implementation RemoveNodesResponse


typedef struct RemoveNodesResponse__storage_ {
  uint32_t _has_storage_[1];
} RemoveNodesResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RemoveNodesResponse class]
                                     rootClass:[IpfsLiteRoot class]
                                          file:IpfsLiteRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(RemoveNodesResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResolveLinkRequest

@implementation ResolveLinkRequest

@dynamic nodeCid;
@dynamic pathArray, pathArray_Count;

typedef struct ResolveLinkRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *nodeCid;
  NSMutableArray *pathArray;
} ResolveLinkRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nodeCid",
        .dataTypeSpecific.className = NULL,
        .number = ResolveLinkRequest_FieldNumber_NodeCid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResolveLinkRequest__storage_, nodeCid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pathArray",
        .dataTypeSpecific.className = NULL,
        .number = ResolveLinkRequest_FieldNumber_PathArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResolveLinkRequest__storage_, pathArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResolveLinkRequest class]
                                     rootClass:[IpfsLiteRoot class]
                                          file:IpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResolveLinkRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResolveLinkResponse

@implementation ResolveLinkResponse

@dynamic hasLink, link;
@dynamic remainingPathArray, remainingPathArray_Count;

typedef struct ResolveLinkResponse__storage_ {
  uint32_t _has_storage_[1];
  Link *link;
  NSMutableArray *remainingPathArray;
} ResolveLinkResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "link",
        .dataTypeSpecific.className = GPBStringifySymbol(Link),
        .number = ResolveLinkResponse_FieldNumber_Link,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResolveLinkResponse__storage_, link),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "remainingPathArray",
        .dataTypeSpecific.className = NULL,
        .number = ResolveLinkResponse_FieldNumber_RemainingPathArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ResolveLinkResponse__storage_, remainingPathArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResolveLinkResponse class]
                                     rootClass:[IpfsLiteRoot class]
                                          file:IpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResolveLinkResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\000remainingPath\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TreeRequest

@implementation TreeRequest

@dynamic nodeCid;
@dynamic path;
@dynamic depth;

typedef struct TreeRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t depth;
  NSString *nodeCid;
  NSString *path;
} TreeRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nodeCid",
        .dataTypeSpecific.className = NULL,
        .number = TreeRequest_FieldNumber_NodeCid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TreeRequest__storage_, nodeCid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "path",
        .dataTypeSpecific.className = NULL,
        .number = TreeRequest_FieldNumber_Path,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TreeRequest__storage_, path),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "depth",
        .dataTypeSpecific.className = NULL,
        .number = TreeRequest_FieldNumber_Depth,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TreeRequest__storage_, depth),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TreeRequest class]
                                     rootClass:[IpfsLiteRoot class]
                                          file:IpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TreeRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TreeResponse

@implementation TreeResponse

@dynamic pathsArray, pathsArray_Count;

typedef struct TreeResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *pathsArray;
} TreeResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pathsArray",
        .dataTypeSpecific.className = NULL,
        .number = TreeResponse_FieldNumber_PathsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TreeResponse__storage_, pathsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TreeResponse class]
                                     rootClass:[IpfsLiteRoot class]
                                          file:IpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TreeResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DeleteBlockRequest

@implementation DeleteBlockRequest

@dynamic cid;

typedef struct DeleteBlockRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *cid;
} DeleteBlockRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cid",
        .dataTypeSpecific.className = NULL,
        .number = DeleteBlockRequest_FieldNumber_Cid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DeleteBlockRequest__storage_, cid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DeleteBlockRequest class]
                                     rootClass:[IpfsLiteRoot class]
                                          file:IpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DeleteBlockRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DeleteBlockResponse

@implementation DeleteBlockResponse


typedef struct DeleteBlockResponse__storage_ {
  uint32_t _has_storage_[1];
} DeleteBlockResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DeleteBlockResponse class]
                                     rootClass:[IpfsLiteRoot class]
                                          file:IpfsLiteRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(DeleteBlockResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - HasBlockRequest

@implementation HasBlockRequest

@dynamic cid;

typedef struct HasBlockRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *cid;
} HasBlockRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cid",
        .dataTypeSpecific.className = NULL,
        .number = HasBlockRequest_FieldNumber_Cid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(HasBlockRequest__storage_, cid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[HasBlockRequest class]
                                     rootClass:[IpfsLiteRoot class]
                                          file:IpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(HasBlockRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - HasBlockResponse

@implementation HasBlockResponse

@dynamic hasBlock;

typedef struct HasBlockResponse__storage_ {
  uint32_t _has_storage_[1];
} HasBlockResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hasBlock",
        .dataTypeSpecific.className = NULL,
        .number = HasBlockResponse_FieldNumber_HasBlock,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[HasBlockResponse class]
                                     rootClass:[IpfsLiteRoot class]
                                          file:IpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(HasBlockResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetBlockRequest

@implementation GetBlockRequest

@dynamic cid;

typedef struct GetBlockRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *cid;
} GetBlockRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cid",
        .dataTypeSpecific.className = NULL,
        .number = GetBlockRequest_FieldNumber_Cid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetBlockRequest__storage_, cid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetBlockRequest class]
                                     rootClass:[IpfsLiteRoot class]
                                          file:IpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetBlockRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetBlockResponse

@implementation GetBlockResponse

@dynamic hasBlock, block;

typedef struct GetBlockResponse__storage_ {
  uint32_t _has_storage_[1];
  Block *block;
} GetBlockResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "block",
        .dataTypeSpecific.className = GPBStringifySymbol(Block),
        .number = GetBlockResponse_FieldNumber_Block,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetBlockResponse__storage_, block),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetBlockResponse class]
                                     rootClass:[IpfsLiteRoot class]
                                          file:IpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetBlockResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetBlockSizeRequest

@implementation GetBlockSizeRequest

@dynamic cid;

typedef struct GetBlockSizeRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *cid;
} GetBlockSizeRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cid",
        .dataTypeSpecific.className = NULL,
        .number = GetBlockSizeRequest_FieldNumber_Cid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetBlockSizeRequest__storage_, cid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetBlockSizeRequest class]
                                     rootClass:[IpfsLiteRoot class]
                                          file:IpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetBlockSizeRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetBlockSizeResponse

@implementation GetBlockSizeResponse

@dynamic size;

typedef struct GetBlockSizeResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t size;
} GetBlockSizeResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "size",
        .dataTypeSpecific.className = NULL,
        .number = GetBlockSizeResponse_FieldNumber_Size,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetBlockSizeResponse__storage_, size),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetBlockSizeResponse class]
                                     rootClass:[IpfsLiteRoot class]
                                          file:IpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetBlockSizeResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PutBlockRequest

@implementation PutBlockRequest

@dynamic hasBlock, block;

typedef struct PutBlockRequest__storage_ {
  uint32_t _has_storage_[1];
  Block *block;
} PutBlockRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "block",
        .dataTypeSpecific.className = GPBStringifySymbol(Block),
        .number = PutBlockRequest_FieldNumber_Block,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PutBlockRequest__storage_, block),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PutBlockRequest class]
                                     rootClass:[IpfsLiteRoot class]
                                          file:IpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PutBlockRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PutBlockResponse

@implementation PutBlockResponse


typedef struct PutBlockResponse__storage_ {
  uint32_t _has_storage_[1];
} PutBlockResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PutBlockResponse class]
                                     rootClass:[IpfsLiteRoot class]
                                          file:IpfsLiteRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PutBlockResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PutBlocksRequest

@implementation PutBlocksRequest

@dynamic blocksArray, blocksArray_Count;

typedef struct PutBlocksRequest__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *blocksArray;
} PutBlocksRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "blocksArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Block),
        .number = PutBlocksRequest_FieldNumber_BlocksArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PutBlocksRequest__storage_, blocksArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PutBlocksRequest class]
                                     rootClass:[IpfsLiteRoot class]
                                          file:IpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PutBlocksRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PutBlocksResponse

@implementation PutBlocksResponse


typedef struct PutBlocksResponse__storage_ {
  uint32_t _has_storage_[1];
} PutBlocksResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PutBlocksResponse class]
                                     rootClass:[IpfsLiteRoot class]
                                          file:IpfsLiteRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(PutBlocksResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AllKeysRequest

@implementation AllKeysRequest


typedef struct AllKeysRequest__storage_ {
  uint32_t _has_storage_[1];
} AllKeysRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AllKeysRequest class]
                                     rootClass:[IpfsLiteRoot class]
                                          file:IpfsLiteRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(AllKeysRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AllKeysResponse

@implementation AllKeysResponse

@dynamic cid;

typedef struct AllKeysResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *cid;
} AllKeysResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cid",
        .dataTypeSpecific.className = NULL,
        .number = AllKeysResponse_FieldNumber_Cid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AllKeysResponse__storage_, cid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AllKeysResponse class]
                                     rootClass:[IpfsLiteRoot class]
                                          file:IpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AllKeysResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - HashOnReadRequest

@implementation HashOnReadRequest

@dynamic hashOnRead;

typedef struct HashOnReadRequest__storage_ {
  uint32_t _has_storage_[1];
} HashOnReadRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hashOnRead",
        .dataTypeSpecific.className = NULL,
        .number = HashOnReadRequest_FieldNumber_HashOnRead,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[HashOnReadRequest class]
                                     rootClass:[IpfsLiteRoot class]
                                          file:IpfsLiteRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(HashOnReadRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - HashOnReadResponse

@implementation HashOnReadResponse


typedef struct HashOnReadResponse__storage_ {
  uint32_t _has_storage_[1];
} HashOnReadResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[HashOnReadResponse class]
                                     rootClass:[IpfsLiteRoot class]
                                          file:IpfsLiteRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(HashOnReadResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
